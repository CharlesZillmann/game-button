/*************************************************************************
 MIT License
 
 Copyright (c) 2019  GameBadge.swift Charles Zillmann charles.zillmann@gmail.com
 

 
 Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
 
 The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
 
 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

//  Generated by PaintCode
//  http://www.paintcodeapp.com

import UIKit

public class GameBadge : NSObject {
    
    //// Cache
    
    private struct Cache {
        static let gradientColor: UIColor = UIColor(red: 0.173, green: 0.184, blue: 0.267, alpha: 1.000)
        static let gradientColor2: UIColor = UIColor(red: 0.408, green: 0.459, blue: 0.725, alpha: 1.000)
        static let asusBlueGrayGradientColor: UIColor = UIColor(red: 0.259, green: 0.314, blue: 0.357, alpha: 1.000)
        static let asusBlueGrayGradientColor2: UIColor = UIColor(red: 0.416, green: 0.471, blue: 0.514, alpha: 1.000)
        static let blueprintGradientColor: UIColor = UIColor(red: 0.125, green: 0.302, blue: 0.443, alpha: 1.000)
        static let blueprintGradientColor2: UIColor = UIColor(red: 0.341, green: 0.498, blue: 0.600, alpha: 1.000)
        static let wetAsphaltGradientColor: UIColor = UIColor(red: 0.204, green: 0.286, blue: 0.369, alpha: 1.000)
        static let wetAsphaltGradientColor2: UIColor = UIColor(red: 0.400, green: 0.482, blue: 0.565, alpha: 1.000)
        static let gradientColor3: UIColor = UIColor(red: 0.235, green: 0.235, blue: 0.235, alpha: 1.000)
        static let whiteGradientColor: UIColor = UIColor(red: 0.882, green: 0.882, blue: 0.882, alpha: 1.000)
        static let goldGradientColor: UIColor = UIColor(red: 0.267, green: 0.216, blue: 0.141, alpha: 1.000)
        static let goldGradientColor2: UIColor = UIColor(red: 0.671, green: 0.592, blue: 0.420, alpha: 1.000)
        static let redGradientColor: UIColor = UIColor(red: 0.804, green: 0.212, blue: 0.224, alpha: 1.000)
        static let redGradientColor2: UIColor = UIColor(red: 1.000, green: 0.447, blue: 0.459, alpha: 1.000)
        static let greenGradientColor: UIColor = UIColor(red: 0.047, green: 0.090, blue: 0.059, alpha: 1.000)
        static let greenGradientColor2: UIColor = UIColor(red: 0.286, green: 0.384, blue: 0.318, alpha: 1.000)
        static let purpleGradient: CGGradient = CGGradient(colorsSpace: nil, colors: [GameBadge.gradientColor.cgColor, GameBadge.gradientColor2.cgColor] as CFArray, locations: [0, 1])!
        static let whiteGradient: CGGradient = CGGradient(colorsSpace: nil, colors: [GameBadge.whiteGradientColor.cgColor, UIColor.white.cgColor] as CFArray, locations: [0, 1])!
        static let goldGradient: CGGradient = CGGradient(colorsSpace: nil, colors: [GameBadge.goldGradientColor.cgColor, GameBadge.goldGradientColor2.cgColor] as CFArray, locations: [0, 1])!
        static let redGradient: CGGradient = CGGradient(colorsSpace: nil, colors: [GameBadge.redGradientColor.cgColor, GameBadge.redGradientColor2.cgColor] as CFArray, locations: [0, 0.99])!
        static let greenGradient: CGGradient = CGGradient(colorsSpace: nil, colors: [GameBadge.greenGradientColor.cgColor, GameBadge.greenGradientColor2.cgColor] as CFArray, locations: [0, 1])!
        static let blueprintGradient: CGGradient = CGGradient(colorsSpace: nil, colors: [GameBadge.blueprintGradientColor.cgColor, GameBadge.blueprintGradientColor2.cgColor] as CFArray, locations: [0, 1])!
        static let wetAsphaltGradient: CGGradient = CGGradient(colorsSpace: nil, colors: [GameBadge.wetAsphaltGradientColor.cgColor, GameBadge.wetAsphaltGradientColor2.cgColor] as CFArray, locations: [0, 1])!
        static let blackGradient: CGGradient = CGGradient(colorsSpace: nil, colors: [UIColor.black.cgColor, GameBadge.gradientColor3.cgColor] as CFArray, locations: [0, 1])!
        static let asusBlueGrayGradient: CGGradient = CGGradient(colorsSpace: nil, colors: [GameBadge.asusBlueGrayGradientColor.cgColor, GameBadge.asusBlueGrayGradientColor2.cgColor] as CFArray, locations: [0, 1])!
        static var image: UIImage?
        
        static var imageOfPurpleBadge: UIImage?
        static var purpleBadgeTargets: [AnyObject]?
        static var imageOfGreenBadge: UIImage?
        static var greenBadgeTargets: [AnyObject]?
        static var imageOfBlueprintBadge: UIImage?
        static var blueprintBadgeTargets: [AnyObject]?
        static var imageOfWetAsphaltBadge: UIImage?
        static var wetAsphaltBadgeTargets: [AnyObject]?
        static var imageOfGoldBadge: UIImage?
        static var goldBadgeTargets: [AnyObject]?
        static var imageOfAsusBlueGreyBadge: UIImage?
        static var asusBlueGreyBadgeTargets: [AnyObject]?
        static var imageOfRedBadge: UIImage?
        static var redBadgeTargets: [AnyObject]?
        static var imageOfWhiteBadge: UIImage?
        static var whiteBadgeTargets: [AnyObject]?
        static var imageOfBlackBadge: UIImage?
        static var blackBadgeTargets: [AnyObject]?
    }
    
    //// Colors
    
    @objc dynamic public class var gradientColor: UIColor { return Cache.gradientColor }
    @objc dynamic public class var gradientColor2: UIColor { return Cache.gradientColor2 }
    @objc dynamic public class var asusBlueGrayGradientColor: UIColor { return Cache.asusBlueGrayGradientColor }
    @objc dynamic public class var asusBlueGrayGradientColor2: UIColor { return Cache.asusBlueGrayGradientColor2 }
    @objc dynamic public class var blueprintGradientColor: UIColor { return Cache.blueprintGradientColor }
    @objc dynamic public class var blueprintGradientColor2: UIColor { return Cache.blueprintGradientColor2 }
    @objc dynamic public class var wetAsphaltGradientColor: UIColor { return Cache.wetAsphaltGradientColor }
    @objc dynamic public class var wetAsphaltGradientColor2: UIColor { return Cache.wetAsphaltGradientColor2 }
    @objc dynamic public class var gradientColor3: UIColor { return Cache.gradientColor3 }
    @objc dynamic public class var whiteGradientColor: UIColor { return Cache.whiteGradientColor }
    @objc dynamic public class var goldGradientColor: UIColor { return Cache.goldGradientColor }
    @objc dynamic public class var goldGradientColor2: UIColor { return Cache.goldGradientColor2 }
    @objc dynamic public class var redGradientColor: UIColor { return Cache.redGradientColor }
    @objc dynamic public class var redGradientColor2: UIColor { return Cache.redGradientColor2 }
    @objc dynamic public class var greenGradientColor: UIColor { return Cache.greenGradientColor }
    @objc dynamic public class var greenGradientColor2: UIColor { return Cache.greenGradientColor2 }
    
    //// Gradients
    
    @objc dynamic public class var purpleGradient: CGGradient { return Cache.purpleGradient }
    @objc dynamic public class var whiteGradient: CGGradient { return Cache.whiteGradient }
    @objc dynamic public class var goldGradient: CGGradient { return Cache.goldGradient }
    @objc dynamic public class var redGradient: CGGradient { return Cache.redGradient }
    @objc dynamic public class var greenGradient: CGGradient { return Cache.greenGradient }
    @objc dynamic public class var blueprintGradient: CGGradient { return Cache.blueprintGradient }
    @objc dynamic public class var wetAsphaltGradient: CGGradient { return Cache.wetAsphaltGradient }
    @objc dynamic public class var blackGradient: CGGradient { return Cache.blackGradient }
    @objc dynamic public class var asusBlueGrayGradient: CGGradient { return Cache.asusBlueGrayGradient }
    
    //// Images
    
    @objc dynamic public class var image: UIImage {
        if Cache.image == nil {
            Cache.image = UIImage(named: "image.png")!
        }
        return Cache.image!
    }
    
    //// Drawing Methods
    
    @objc dynamic public class func drawPurpleBadge(frame targetFrame: CGRect = CGRect(x: 0, y: 0, width: 452, height: 540), resizing: ResizingBehavior = .aspectFit) {
        //// General Declarations
        let context = UIGraphicsGetCurrentContext()!
        
        //// Resize to Target Frame
        context.saveGState()
        let resizedFrame: CGRect = resizing.apply(rect: CGRect(x: 0, y: 0, width: 452, height: 540), target: targetFrame)
        context.translateBy(x: resizedFrame.minX, y: resizedFrame.minY)
        context.scaleBy(x: resizedFrame.width / 452, y: resizedFrame.height / 540)
        
        
        //// Bezier Drawing
        let bezierPath = UIBezierPath()
        bezierPath.move(to: CGPoint(x: 447, y: 11))
        bezierPath.addCurve(to: CGPoint(x: 447, y: 441), controlPoint1: CGPoint(x: 447, y: 11), controlPoint2: CGPoint(x: 447, y: 441))
        bezierPath.addLine(to: CGPoint(x: 445.77, y: 441))
        bezierPath.addCurve(to: CGPoint(x: 226.5, y: 538), controlPoint1: CGPoint(x: 428.81, y: 448.51), controlPoint2: CGPoint(x: 226.5, y: 538))
        bezierPath.addCurve(to: CGPoint(x: 7.23, y: 441), controlPoint1: CGPoint(x: 226.5, y: 538), controlPoint2: CGPoint(x: 24.19, y: 448.51))
        bezierPath.addLine(to: CGPoint(x: 6, y: 441))
        bezierPath.addLine(to: CGPoint(x: 6, y: 11))
        bezierPath.addLine(to: CGPoint(x: 447, y: 11))
        bezierPath.addLine(to: CGPoint(x: 447, y: 11))
        bezierPath.close()
        context.saveGState()
        bezierPath.addClip()
        context.drawLinearGradient(GameBadge.purpleGradient, start: CGPoint(x: 226.5, y: 11), end: CGPoint(x: 226.5, y: 538), options: [])
        context.restoreGState()
        
        
        //// Bezier 2 Drawing
        let bezier2Path = UIBezierPath()
        bezier2Path.move(to: CGPoint(x: 435, y: 21))
        bezier2Path.addCurve(to: CGPoint(x: 435, y: 431.42), controlPoint1: CGPoint(x: 435, y: 21), controlPoint2: CGPoint(x: 435, y: 431.42))
        bezier2Path.addLine(to: CGPoint(x: 433.83, y: 431.42))
        bezier2Path.addCurve(to: CGPoint(x: 225.5, y: 524), controlPoint1: CGPoint(x: 417.71, y: 438.58), controlPoint2: CGPoint(x: 225.5, y: 524))
        bezier2Path.addCurve(to: CGPoint(x: 17.17, y: 431.42), controlPoint1: CGPoint(x: 225.5, y: 524), controlPoint2: CGPoint(x: 33.29, y: 438.58))
        bezier2Path.addLine(to: CGPoint(x: 16, y: 431.42))
        bezier2Path.addLine(to: CGPoint(x: 16, y: 21))
        bezier2Path.addLine(to: CGPoint(x: 435, y: 21))
        bezier2Path.addLine(to: CGPoint(x: 435, y: 21))
        bezier2Path.close()
        context.saveGState()
        bezier2Path.addClip()
        context.drawLinearGradient(GameBadge.purpleGradient, start: CGPoint(x: 225.5, y: 21), end: CGPoint(x: 225.5, y: 524), options: [])
        context.restoreGState()
        UIColor.white.setStroke()
        bezier2Path.lineWidth = 2
        bezier2Path.stroke()
        
        context.restoreGState()
        
    }
    
    @objc dynamic public class func drawGreenBadge(frame targetFrame: CGRect = CGRect(x: 0, y: 0, width: 452, height: 540), resizing: ResizingBehavior = .aspectFit) {
        //// General Declarations
        let context = UIGraphicsGetCurrentContext()!
        
        //// Resize to Target Frame
        context.saveGState()
        let resizedFrame: CGRect = resizing.apply(rect: CGRect(x: 0, y: 0, width: 452, height: 540), target: targetFrame)
        context.translateBy(x: resizedFrame.minX, y: resizedFrame.minY)
        context.scaleBy(x: resizedFrame.width / 452, y: resizedFrame.height / 540)
        
        
        //// Bezier Drawing
        let bezierPath = UIBezierPath()
        bezierPath.move(to: CGPoint(x: 447, y: 11))
        bezierPath.addCurve(to: CGPoint(x: 447, y: 441), controlPoint1: CGPoint(x: 447, y: 11), controlPoint2: CGPoint(x: 447, y: 441))
        bezierPath.addLine(to: CGPoint(x: 445.77, y: 441))
        bezierPath.addCurve(to: CGPoint(x: 226.5, y: 538), controlPoint1: CGPoint(x: 428.81, y: 448.51), controlPoint2: CGPoint(x: 226.5, y: 538))
        bezierPath.addCurve(to: CGPoint(x: 7.23, y: 441), controlPoint1: CGPoint(x: 226.5, y: 538), controlPoint2: CGPoint(x: 24.19, y: 448.51))
        bezierPath.addLine(to: CGPoint(x: 6, y: 441))
        bezierPath.addLine(to: CGPoint(x: 6, y: 11))
        bezierPath.addLine(to: CGPoint(x: 447, y: 11))
        bezierPath.addLine(to: CGPoint(x: 447, y: 11))
        bezierPath.close()
        context.saveGState()
        bezierPath.addClip()
        context.drawLinearGradient(GameBadge.greenGradient, start: CGPoint(x: 226.5, y: 11), end: CGPoint(x: 226.5, y: 538), options: [])
        context.restoreGState()
        
        
        //// Bezier 2 Drawing
        let bezier2Path = UIBezierPath()
        bezier2Path.move(to: CGPoint(x: 435, y: 21))
        bezier2Path.addCurve(to: CGPoint(x: 435, y: 431.42), controlPoint1: CGPoint(x: 435, y: 21), controlPoint2: CGPoint(x: 435, y: 431.42))
        bezier2Path.addLine(to: CGPoint(x: 433.83, y: 431.42))
        bezier2Path.addCurve(to: CGPoint(x: 225.5, y: 524), controlPoint1: CGPoint(x: 417.71, y: 438.58), controlPoint2: CGPoint(x: 225.5, y: 524))
        bezier2Path.addCurve(to: CGPoint(x: 17.17, y: 431.42), controlPoint1: CGPoint(x: 225.5, y: 524), controlPoint2: CGPoint(x: 33.29, y: 438.58))
        bezier2Path.addLine(to: CGPoint(x: 16, y: 431.42))
        bezier2Path.addLine(to: CGPoint(x: 16, y: 21))
        bezier2Path.addLine(to: CGPoint(x: 435, y: 21))
        bezier2Path.addLine(to: CGPoint(x: 435, y: 21))
        bezier2Path.close()
        context.saveGState()
        bezier2Path.addClip()
        context.drawLinearGradient(GameBadge.greenGradient, start: CGPoint(x: 225.5, y: 21), end: CGPoint(x: 225.5, y: 524), options: [])
        context.restoreGState()
        UIColor.white.setStroke()
        bezier2Path.lineWidth = 2
        bezier2Path.stroke()
        
        context.restoreGState()
        
    }
    
    @objc dynamic public class func drawBlueprintBadge(frame targetFrame: CGRect = CGRect(x: 0, y: 0, width: 452, height: 540), resizing: ResizingBehavior = .aspectFit) {
        //// General Declarations
        let context = UIGraphicsGetCurrentContext()!
        
        //// Resize to Target Frame
        context.saveGState()
        let resizedFrame: CGRect = resizing.apply(rect: CGRect(x: 0, y: 0, width: 452, height: 540), target: targetFrame)
        context.translateBy(x: resizedFrame.minX, y: resizedFrame.minY)
        context.scaleBy(x: resizedFrame.width / 452, y: resizedFrame.height / 540)
        
        
        //// Bezier Drawing
        let bezierPath = UIBezierPath()
        bezierPath.move(to: CGPoint(x: 447, y: 11))
        bezierPath.addCurve(to: CGPoint(x: 447, y: 441), controlPoint1: CGPoint(x: 447, y: 11), controlPoint2: CGPoint(x: 447, y: 441))
        bezierPath.addLine(to: CGPoint(x: 445.77, y: 441))
        bezierPath.addCurve(to: CGPoint(x: 226.5, y: 538), controlPoint1: CGPoint(x: 428.81, y: 448.51), controlPoint2: CGPoint(x: 226.5, y: 538))
        bezierPath.addCurve(to: CGPoint(x: 7.23, y: 441), controlPoint1: CGPoint(x: 226.5, y: 538), controlPoint2: CGPoint(x: 24.19, y: 448.51))
        bezierPath.addLine(to: CGPoint(x: 6, y: 441))
        bezierPath.addLine(to: CGPoint(x: 6, y: 11))
        bezierPath.addLine(to: CGPoint(x: 447, y: 11))
        bezierPath.addLine(to: CGPoint(x: 447, y: 11))
        bezierPath.close()
        context.saveGState()
        bezierPath.addClip()
        context.drawLinearGradient(GameBadge.blueprintGradient, start: CGPoint(x: 226.5, y: 11), end: CGPoint(x: 226.5, y: 538), options: [])
        context.restoreGState()
        
        
        //// Bezier 2 Drawing
        let bezier2Path = UIBezierPath()
        bezier2Path.move(to: CGPoint(x: 435, y: 21))
        bezier2Path.addCurve(to: CGPoint(x: 435, y: 431.42), controlPoint1: CGPoint(x: 435, y: 21), controlPoint2: CGPoint(x: 435, y: 431.42))
        bezier2Path.addLine(to: CGPoint(x: 433.83, y: 431.42))
        bezier2Path.addCurve(to: CGPoint(x: 225.5, y: 524), controlPoint1: CGPoint(x: 417.71, y: 438.58), controlPoint2: CGPoint(x: 225.5, y: 524))
        bezier2Path.addCurve(to: CGPoint(x: 17.17, y: 431.42), controlPoint1: CGPoint(x: 225.5, y: 524), controlPoint2: CGPoint(x: 33.29, y: 438.58))
        bezier2Path.addLine(to: CGPoint(x: 16, y: 431.42))
        bezier2Path.addLine(to: CGPoint(x: 16, y: 21))
        bezier2Path.addLine(to: CGPoint(x: 435, y: 21))
        bezier2Path.addLine(to: CGPoint(x: 435, y: 21))
        bezier2Path.close()
        context.saveGState()
        bezier2Path.addClip()
        context.drawLinearGradient(GameBadge.blueprintGradient, start: CGPoint(x: 225.5, y: 21), end: CGPoint(x: 225.5, y: 524), options: [])
        context.restoreGState()
        UIColor.white.setStroke()
        bezier2Path.lineWidth = 2
        bezier2Path.stroke()
        
        context.restoreGState()
        
    }
    
    @objc dynamic public class func drawWetAsphaltBadge(frame targetFrame: CGRect = CGRect(x: 0, y: 0, width: 452, height: 540), resizing: ResizingBehavior = .aspectFit) {
        //// General Declarations
        let context = UIGraphicsGetCurrentContext()!
        
        //// Resize to Target Frame
        context.saveGState()
        let resizedFrame: CGRect = resizing.apply(rect: CGRect(x: 0, y: 0, width: 452, height: 540), target: targetFrame)
        context.translateBy(x: resizedFrame.minX, y: resizedFrame.minY)
        context.scaleBy(x: resizedFrame.width / 452, y: resizedFrame.height / 540)
        
        
        //// Bezier Drawing
        let bezierPath = UIBezierPath()
        bezierPath.move(to: CGPoint(x: 447, y: 11))
        bezierPath.addCurve(to: CGPoint(x: 447, y: 441), controlPoint1: CGPoint(x: 447, y: 11), controlPoint2: CGPoint(x: 447, y: 441))
        bezierPath.addLine(to: CGPoint(x: 445.77, y: 441))
        bezierPath.addCurve(to: CGPoint(x: 226.5, y: 538), controlPoint1: CGPoint(x: 428.81, y: 448.51), controlPoint2: CGPoint(x: 226.5, y: 538))
        bezierPath.addCurve(to: CGPoint(x: 7.23, y: 441), controlPoint1: CGPoint(x: 226.5, y: 538), controlPoint2: CGPoint(x: 24.19, y: 448.51))
        bezierPath.addLine(to: CGPoint(x: 6, y: 441))
        bezierPath.addLine(to: CGPoint(x: 6, y: 11))
        bezierPath.addLine(to: CGPoint(x: 447, y: 11))
        bezierPath.addLine(to: CGPoint(x: 447, y: 11))
        bezierPath.close()
        context.saveGState()
        bezierPath.addClip()
        context.drawLinearGradient(GameBadge.wetAsphaltGradient, start: CGPoint(x: 226.5, y: 11), end: CGPoint(x: 226.5, y: 538), options: [])
        context.restoreGState()
        
        
        //// Bezier 2 Drawing
        let bezier2Path = UIBezierPath()
        bezier2Path.move(to: CGPoint(x: 435, y: 21))
        bezier2Path.addCurve(to: CGPoint(x: 435, y: 431.42), controlPoint1: CGPoint(x: 435, y: 21), controlPoint2: CGPoint(x: 435, y: 431.42))
        bezier2Path.addLine(to: CGPoint(x: 433.83, y: 431.42))
        bezier2Path.addCurve(to: CGPoint(x: 225.5, y: 524), controlPoint1: CGPoint(x: 417.71, y: 438.58), controlPoint2: CGPoint(x: 225.5, y: 524))
        bezier2Path.addCurve(to: CGPoint(x: 17.17, y: 431.42), controlPoint1: CGPoint(x: 225.5, y: 524), controlPoint2: CGPoint(x: 33.29, y: 438.58))
        bezier2Path.addLine(to: CGPoint(x: 16, y: 431.42))
        bezier2Path.addLine(to: CGPoint(x: 16, y: 21))
        bezier2Path.addLine(to: CGPoint(x: 435, y: 21))
        bezier2Path.addLine(to: CGPoint(x: 435, y: 21))
        bezier2Path.close()
        context.saveGState()
        bezier2Path.addClip()
        context.drawLinearGradient(GameBadge.wetAsphaltGradient, start: CGPoint(x: 225.5, y: 21), end: CGPoint(x: 225.5, y: 524), options: [])
        context.restoreGState()
        UIColor.white.setStroke()
        bezier2Path.lineWidth = 2
        bezier2Path.stroke()
        
        context.restoreGState()
        
    }
    
    @objc dynamic public class func drawGoldBadge(frame targetFrame: CGRect = CGRect(x: 0, y: 0, width: 452, height: 540), resizing: ResizingBehavior = .aspectFit) {
        //// General Declarations
        let context = UIGraphicsGetCurrentContext()!
        
        //// Resize to Target Frame
        context.saveGState()
        let resizedFrame: CGRect = resizing.apply(rect: CGRect(x: 0, y: 0, width: 452, height: 540), target: targetFrame)
        context.translateBy(x: resizedFrame.minX, y: resizedFrame.minY)
        context.scaleBy(x: resizedFrame.width / 452, y: resizedFrame.height / 540)
        
        
        //// Bezier Drawing
        let bezierPath = UIBezierPath()
        bezierPath.move(to: CGPoint(x: 447, y: 11))
        bezierPath.addCurve(to: CGPoint(x: 447, y: 441), controlPoint1: CGPoint(x: 447, y: 11), controlPoint2: CGPoint(x: 447, y: 441))
        bezierPath.addLine(to: CGPoint(x: 445.77, y: 441))
        bezierPath.addCurve(to: CGPoint(x: 226.5, y: 538), controlPoint1: CGPoint(x: 428.81, y: 448.51), controlPoint2: CGPoint(x: 226.5, y: 538))
        bezierPath.addCurve(to: CGPoint(x: 7.23, y: 441), controlPoint1: CGPoint(x: 226.5, y: 538), controlPoint2: CGPoint(x: 24.19, y: 448.51))
        bezierPath.addLine(to: CGPoint(x: 6, y: 441))
        bezierPath.addLine(to: CGPoint(x: 6, y: 11))
        bezierPath.addLine(to: CGPoint(x: 447, y: 11))
        bezierPath.addLine(to: CGPoint(x: 447, y: 11))
        bezierPath.close()
        context.saveGState()
        bezierPath.addClip()
        context.drawLinearGradient(GameBadge.goldGradient, start: CGPoint(x: 226.5, y: 11), end: CGPoint(x: 226.5, y: 538), options: [])
        context.restoreGState()
        
        
        //// Bezier 2 Drawing
        let bezier2Path = UIBezierPath()
        bezier2Path.move(to: CGPoint(x: 435, y: 21))
        bezier2Path.addCurve(to: CGPoint(x: 435, y: 431.42), controlPoint1: CGPoint(x: 435, y: 21), controlPoint2: CGPoint(x: 435, y: 431.42))
        bezier2Path.addLine(to: CGPoint(x: 433.83, y: 431.42))
        bezier2Path.addCurve(to: CGPoint(x: 225.5, y: 524), controlPoint1: CGPoint(x: 417.71, y: 438.58), controlPoint2: CGPoint(x: 225.5, y: 524))
        bezier2Path.addCurve(to: CGPoint(x: 17.17, y: 431.42), controlPoint1: CGPoint(x: 225.5, y: 524), controlPoint2: CGPoint(x: 33.29, y: 438.58))
        bezier2Path.addLine(to: CGPoint(x: 16, y: 431.42))
        bezier2Path.addLine(to: CGPoint(x: 16, y: 21))
        bezier2Path.addLine(to: CGPoint(x: 435, y: 21))
        bezier2Path.addLine(to: CGPoint(x: 435, y: 21))
        bezier2Path.close()
        context.saveGState()
        bezier2Path.addClip()
        context.drawLinearGradient(GameBadge.goldGradient, start: CGPoint(x: 225.5, y: 21), end: CGPoint(x: 225.5, y: 524), options: [])
        context.restoreGState()
        UIColor.white.setStroke()
        bezier2Path.lineWidth = 2
        bezier2Path.stroke()
        
        context.restoreGState()
        
    }
    
    @objc dynamic public class func drawAsusBlueGreyBadge(frame targetFrame: CGRect = CGRect(x: 0, y: 0, width: 452, height: 540), resizing: ResizingBehavior = .aspectFit) {
        //// General Declarations
        let context = UIGraphicsGetCurrentContext()!
        
        //// Resize to Target Frame
        context.saveGState()
        let resizedFrame: CGRect = resizing.apply(rect: CGRect(x: 0, y: 0, width: 452, height: 540), target: targetFrame)
        context.translateBy(x: resizedFrame.minX, y: resizedFrame.minY)
        context.scaleBy(x: resizedFrame.width / 452, y: resizedFrame.height / 540)
        
        
        //// Bezier Drawing
        let bezierPath = UIBezierPath()
        bezierPath.move(to: CGPoint(x: 447, y: 11))
        bezierPath.addCurve(to: CGPoint(x: 447, y: 441), controlPoint1: CGPoint(x: 447, y: 11), controlPoint2: CGPoint(x: 447, y: 441))
        bezierPath.addLine(to: CGPoint(x: 445.77, y: 441))
        bezierPath.addCurve(to: CGPoint(x: 226.5, y: 538), controlPoint1: CGPoint(x: 428.81, y: 448.51), controlPoint2: CGPoint(x: 226.5, y: 538))
        bezierPath.addCurve(to: CGPoint(x: 7.23, y: 441), controlPoint1: CGPoint(x: 226.5, y: 538), controlPoint2: CGPoint(x: 24.19, y: 448.51))
        bezierPath.addLine(to: CGPoint(x: 6, y: 441))
        bezierPath.addLine(to: CGPoint(x: 6, y: 11))
        bezierPath.addLine(to: CGPoint(x: 447, y: 11))
        bezierPath.addLine(to: CGPoint(x: 447, y: 11))
        bezierPath.close()
        context.saveGState()
        bezierPath.addClip()
        context.drawLinearGradient(GameBadge.asusBlueGrayGradient, start: CGPoint(x: 226.5, y: 11), end: CGPoint(x: 226.5, y: 538), options: [])
        context.restoreGState()
        
        
        //// Bezier 2 Drawing
        let bezier2Path = UIBezierPath()
        bezier2Path.move(to: CGPoint(x: 435, y: 21))
        bezier2Path.addCurve(to: CGPoint(x: 435, y: 431.42), controlPoint1: CGPoint(x: 435, y: 21), controlPoint2: CGPoint(x: 435, y: 431.42))
        bezier2Path.addLine(to: CGPoint(x: 433.83, y: 431.42))
        bezier2Path.addCurve(to: CGPoint(x: 225.5, y: 524), controlPoint1: CGPoint(x: 417.71, y: 438.58), controlPoint2: CGPoint(x: 225.5, y: 524))
        bezier2Path.addCurve(to: CGPoint(x: 17.17, y: 431.42), controlPoint1: CGPoint(x: 225.5, y: 524), controlPoint2: CGPoint(x: 33.29, y: 438.58))
        bezier2Path.addLine(to: CGPoint(x: 16, y: 431.42))
        bezier2Path.addLine(to: CGPoint(x: 16, y: 21))
        bezier2Path.addLine(to: CGPoint(x: 435, y: 21))
        bezier2Path.addLine(to: CGPoint(x: 435, y: 21))
        bezier2Path.close()
        context.saveGState()
        bezier2Path.addClip()
        context.drawLinearGradient(GameBadge.asusBlueGrayGradient, start: CGPoint(x: 225.5, y: 21), end: CGPoint(x: 225.5, y: 524), options: [])
        context.restoreGState()
        UIColor.white.setStroke()
        bezier2Path.lineWidth = 2
        bezier2Path.stroke()
        
        context.restoreGState()
        
    }
    
    @objc dynamic public class func drawRedBadge(frame targetFrame: CGRect = CGRect(x: 0, y: 0, width: 452, height: 540), resizing: ResizingBehavior = .aspectFit) {
        //// General Declarations
        let context = UIGraphicsGetCurrentContext()!
        
        //// Resize to Target Frame
        context.saveGState()
        let resizedFrame: CGRect = resizing.apply(rect: CGRect(x: 0, y: 0, width: 452, height: 540), target: targetFrame)
        context.translateBy(x: resizedFrame.minX, y: resizedFrame.minY)
        context.scaleBy(x: resizedFrame.width / 452, y: resizedFrame.height / 540)
        
        
        //// Bezier Drawing
        let bezierPath = UIBezierPath()
        bezierPath.move(to: CGPoint(x: 447, y: 11))
        bezierPath.addCurve(to: CGPoint(x: 447, y: 441), controlPoint1: CGPoint(x: 447, y: 11), controlPoint2: CGPoint(x: 447, y: 441))
        bezierPath.addLine(to: CGPoint(x: 445.77, y: 441))
        bezierPath.addCurve(to: CGPoint(x: 226.5, y: 538), controlPoint1: CGPoint(x: 428.81, y: 448.51), controlPoint2: CGPoint(x: 226.5, y: 538))
        bezierPath.addCurve(to: CGPoint(x: 7.23, y: 441), controlPoint1: CGPoint(x: 226.5, y: 538), controlPoint2: CGPoint(x: 24.19, y: 448.51))
        bezierPath.addLine(to: CGPoint(x: 6, y: 441))
        bezierPath.addLine(to: CGPoint(x: 6, y: 11))
        bezierPath.addLine(to: CGPoint(x: 447, y: 11))
        bezierPath.addLine(to: CGPoint(x: 447, y: 11))
        bezierPath.close()
        context.saveGState()
        bezierPath.addClip()
        context.drawLinearGradient(GameBadge.redGradient, start: CGPoint(x: 226.5, y: 11), end: CGPoint(x: 226.5, y: 538), options: [])
        context.restoreGState()
        
        
        //// Bezier 2 Drawing
        let bezier2Path = UIBezierPath()
        bezier2Path.move(to: CGPoint(x: 435, y: 21))
        bezier2Path.addCurve(to: CGPoint(x: 435, y: 431.42), controlPoint1: CGPoint(x: 435, y: 21), controlPoint2: CGPoint(x: 435, y: 431.42))
        bezier2Path.addLine(to: CGPoint(x: 433.83, y: 431.42))
        bezier2Path.addCurve(to: CGPoint(x: 225.5, y: 524), controlPoint1: CGPoint(x: 417.71, y: 438.58), controlPoint2: CGPoint(x: 225.5, y: 524))
        bezier2Path.addCurve(to: CGPoint(x: 17.17, y: 431.42), controlPoint1: CGPoint(x: 225.5, y: 524), controlPoint2: CGPoint(x: 33.29, y: 438.58))
        bezier2Path.addLine(to: CGPoint(x: 16, y: 431.42))
        bezier2Path.addLine(to: CGPoint(x: 16, y: 21))
        bezier2Path.addLine(to: CGPoint(x: 435, y: 21))
        bezier2Path.addLine(to: CGPoint(x: 435, y: 21))
        bezier2Path.close()
        context.saveGState()
        bezier2Path.addClip()
        context.drawLinearGradient(GameBadge.redGradient, start: CGPoint(x: 225.5, y: 21), end: CGPoint(x: 225.5, y: 524), options: [])
        context.restoreGState()
        UIColor.white.setStroke()
        bezier2Path.lineWidth = 2
        bezier2Path.stroke()
        
        context.restoreGState()
        
    }
    
    @objc dynamic public class func drawWhiteBadge(frame targetFrame: CGRect = CGRect(x: 0, y: 0, width: 452, height: 540), resizing: ResizingBehavior = .aspectFit) {
        //// General Declarations
        let context = UIGraphicsGetCurrentContext()!
        
        //// Resize to Target Frame
        context.saveGState()
        let resizedFrame: CGRect = resizing.apply(rect: CGRect(x: 0, y: 0, width: 452, height: 540), target: targetFrame)
        context.translateBy(x: resizedFrame.minX, y: resizedFrame.minY)
        context.scaleBy(x: resizedFrame.width / 452, y: resizedFrame.height / 540)
        
        
        //// Bezier Drawing
        let bezierPath = UIBezierPath()
        bezierPath.move(to: CGPoint(x: 447, y: 11))
        bezierPath.addCurve(to: CGPoint(x: 447, y: 441), controlPoint1: CGPoint(x: 447, y: 11), controlPoint2: CGPoint(x: 447, y: 441))
        bezierPath.addLine(to: CGPoint(x: 445.77, y: 441))
        bezierPath.addCurve(to: CGPoint(x: 226.5, y: 538), controlPoint1: CGPoint(x: 428.81, y: 448.51), controlPoint2: CGPoint(x: 226.5, y: 538))
        bezierPath.addCurve(to: CGPoint(x: 7.23, y: 441), controlPoint1: CGPoint(x: 226.5, y: 538), controlPoint2: CGPoint(x: 24.19, y: 448.51))
        bezierPath.addLine(to: CGPoint(x: 6, y: 441))
        bezierPath.addLine(to: CGPoint(x: 6, y: 11))
        bezierPath.addLine(to: CGPoint(x: 447, y: 11))
        bezierPath.addLine(to: CGPoint(x: 447, y: 11))
        bezierPath.close()
        context.saveGState()
        bezierPath.addClip()
        context.drawLinearGradient(GameBadge.whiteGradient, start: CGPoint(x: 226.5, y: 11), end: CGPoint(x: 226.5, y: 538), options: [])
        context.restoreGState()
        UIColor.black.setStroke()
        bezierPath.lineWidth = 1
        bezierPath.stroke()
        
        
        //// Bezier 2 Drawing
        let bezier2Path = UIBezierPath()
        bezier2Path.move(to: CGPoint(x: 435, y: 21))
        bezier2Path.addCurve(to: CGPoint(x: 435, y: 431.42), controlPoint1: CGPoint(x: 435, y: 21), controlPoint2: CGPoint(x: 435, y: 431.42))
        bezier2Path.addLine(to: CGPoint(x: 433.83, y: 431.42))
        bezier2Path.addCurve(to: CGPoint(x: 225.5, y: 524), controlPoint1: CGPoint(x: 417.71, y: 438.58), controlPoint2: CGPoint(x: 225.5, y: 524))
        bezier2Path.addCurve(to: CGPoint(x: 17.17, y: 431.42), controlPoint1: CGPoint(x: 225.5, y: 524), controlPoint2: CGPoint(x: 33.29, y: 438.58))
        bezier2Path.addLine(to: CGPoint(x: 16, y: 431.42))
        bezier2Path.addLine(to: CGPoint(x: 16, y: 21))
        bezier2Path.addLine(to: CGPoint(x: 435, y: 21))
        bezier2Path.addLine(to: CGPoint(x: 435, y: 21))
        bezier2Path.close()
        context.saveGState()
        bezier2Path.addClip()
        context.drawLinearGradient(GameBadge.whiteGradient, start: CGPoint(x: 225.5, y: 21), end: CGPoint(x: 225.5, y: 524), options: [])
        context.restoreGState()
        UIColor.black.setStroke()
        bezier2Path.lineWidth = 2
        bezier2Path.stroke()
        
        context.restoreGState()
        
    }
    
    @objc dynamic public class func drawBlackBadge(frame targetFrame: CGRect = CGRect(x: 0, y: 0, width: 452, height: 540), resizing: ResizingBehavior = .aspectFit) {
        //// General Declarations
        let context = UIGraphicsGetCurrentContext()!
        
        //// Resize to Target Frame
        context.saveGState()
        let resizedFrame: CGRect = resizing.apply(rect: CGRect(x: 0, y: 0, width: 452, height: 540), target: targetFrame)
        context.translateBy(x: resizedFrame.minX, y: resizedFrame.minY)
        context.scaleBy(x: resizedFrame.width / 452, y: resizedFrame.height / 540)
        
        
        //// Bezier Drawing
        let bezierPath = UIBezierPath()
        bezierPath.move(to: CGPoint(x: 447, y: 11))
        bezierPath.addCurve(to: CGPoint(x: 447, y: 441), controlPoint1: CGPoint(x: 447, y: 11), controlPoint2: CGPoint(x: 447, y: 441))
        bezierPath.addLine(to: CGPoint(x: 445.77, y: 441))
        bezierPath.addCurve(to: CGPoint(x: 226.5, y: 538), controlPoint1: CGPoint(x: 428.81, y: 448.51), controlPoint2: CGPoint(x: 226.5, y: 538))
        bezierPath.addCurve(to: CGPoint(x: 7.23, y: 441), controlPoint1: CGPoint(x: 226.5, y: 538), controlPoint2: CGPoint(x: 24.19, y: 448.51))
        bezierPath.addLine(to: CGPoint(x: 6, y: 441))
        bezierPath.addLine(to: CGPoint(x: 6, y: 11))
        bezierPath.addLine(to: CGPoint(x: 447, y: 11))
        bezierPath.addLine(to: CGPoint(x: 447, y: 11))
        bezierPath.close()
        context.saveGState()
        bezierPath.addClip()
        context.drawLinearGradient(GameBadge.blackGradient, start: CGPoint(x: 226.5, y: 11), end: CGPoint(x: 226.5, y: 538), options: [])
        context.restoreGState()
        
        
        //// Bezier 2 Drawing
        let bezier2Path = UIBezierPath()
        bezier2Path.move(to: CGPoint(x: 435, y: 21))
        bezier2Path.addCurve(to: CGPoint(x: 435, y: 431.42), controlPoint1: CGPoint(x: 435, y: 21), controlPoint2: CGPoint(x: 435, y: 431.42))
        bezier2Path.addLine(to: CGPoint(x: 433.83, y: 431.42))
        bezier2Path.addCurve(to: CGPoint(x: 225.5, y: 524), controlPoint1: CGPoint(x: 417.71, y: 438.58), controlPoint2: CGPoint(x: 225.5, y: 524))
        bezier2Path.addCurve(to: CGPoint(x: 17.17, y: 431.42), controlPoint1: CGPoint(x: 225.5, y: 524), controlPoint2: CGPoint(x: 33.29, y: 438.58))
        bezier2Path.addLine(to: CGPoint(x: 16, y: 431.42))
        bezier2Path.addLine(to: CGPoint(x: 16, y: 21))
        bezier2Path.addLine(to: CGPoint(x: 435, y: 21))
        bezier2Path.addLine(to: CGPoint(x: 435, y: 21))
        bezier2Path.close()
        context.saveGState()
        bezier2Path.addClip()
        context.drawLinearGradient(GameBadge.blackGradient, start: CGPoint(x: 225.5, y: 21), end: CGPoint(x: 225.5, y: 524), options: [])
        context.restoreGState()
        UIColor.white.setStroke()
        bezier2Path.lineWidth = 2
        bezier2Path.stroke()
        
        context.restoreGState()
        
    }
    
    //// Generated Images
    
    @objc dynamic public class var imageOfPurpleBadge: UIImage {
        if Cache.imageOfPurpleBadge != nil {
            return Cache.imageOfPurpleBadge!
        }
        
        UIGraphicsBeginImageContextWithOptions(CGSize(width: 452, height: 540), false, 0)
        GameBadge.drawPurpleBadge()
        
        Cache.imageOfPurpleBadge = UIGraphicsGetImageFromCurrentImageContext()!
        UIGraphicsEndImageContext()
        
        return Cache.imageOfPurpleBadge!
    }
    
    @objc dynamic public class var imageOfGreenBadge: UIImage {
        if Cache.imageOfGreenBadge != nil {
            return Cache.imageOfGreenBadge!
        }
        
        UIGraphicsBeginImageContextWithOptions(CGSize(width: 452, height: 540), false, 0)
        GameBadge.drawGreenBadge()
        
        Cache.imageOfGreenBadge = UIGraphicsGetImageFromCurrentImageContext()!
        UIGraphicsEndImageContext()
        
        return Cache.imageOfGreenBadge!
    }
    
    @objc dynamic public class var imageOfBlueprintBadge: UIImage {
        if Cache.imageOfBlueprintBadge != nil {
            return Cache.imageOfBlueprintBadge!
        }
        
        UIGraphicsBeginImageContextWithOptions(CGSize(width: 452, height: 540), false, 0)
        GameBadge.drawBlueprintBadge()
        
        Cache.imageOfBlueprintBadge = UIGraphicsGetImageFromCurrentImageContext()!
        UIGraphicsEndImageContext()
        
        return Cache.imageOfBlueprintBadge!
    }
    
    @objc dynamic public class var imageOfWetAsphaltBadge: UIImage {
        if Cache.imageOfWetAsphaltBadge != nil {
            return Cache.imageOfWetAsphaltBadge!
        }
        
        UIGraphicsBeginImageContextWithOptions(CGSize(width: 452, height: 540), false, 0)
        GameBadge.drawWetAsphaltBadge()
        
        Cache.imageOfWetAsphaltBadge = UIGraphicsGetImageFromCurrentImageContext()!
        UIGraphicsEndImageContext()
        
        return Cache.imageOfWetAsphaltBadge!
    }
    
    @objc dynamic public class var imageOfGoldBadge: UIImage {
        if Cache.imageOfGoldBadge != nil {
            return Cache.imageOfGoldBadge!
        }
        
        UIGraphicsBeginImageContextWithOptions(CGSize(width: 452, height: 540), false, 0)
        GameBadge.drawGoldBadge()
        
        Cache.imageOfGoldBadge = UIGraphicsGetImageFromCurrentImageContext()!
        UIGraphicsEndImageContext()
        
        return Cache.imageOfGoldBadge!
    }
    
    @objc dynamic public class var imageOfAsusBlueGreyBadge: UIImage {
        if Cache.imageOfAsusBlueGreyBadge != nil {
            return Cache.imageOfAsusBlueGreyBadge!
        }
        
        UIGraphicsBeginImageContextWithOptions(CGSize(width: 452, height: 540), false, 0)
        GameBadge.drawAsusBlueGreyBadge()
        
        Cache.imageOfAsusBlueGreyBadge = UIGraphicsGetImageFromCurrentImageContext()!
        UIGraphicsEndImageContext()
        
        return Cache.imageOfAsusBlueGreyBadge!
    }
    
    @objc dynamic public class var imageOfRedBadge: UIImage {
        if Cache.imageOfRedBadge != nil {
            return Cache.imageOfRedBadge!
        }
        
        UIGraphicsBeginImageContextWithOptions(CGSize(width: 452, height: 540), false, 0)
        GameBadge.drawRedBadge()
        
        Cache.imageOfRedBadge = UIGraphicsGetImageFromCurrentImageContext()!
        UIGraphicsEndImageContext()
        
        return Cache.imageOfRedBadge!
    }
    
    @objc dynamic public class var imageOfWhiteBadge: UIImage {
        if Cache.imageOfWhiteBadge != nil {
            return Cache.imageOfWhiteBadge!
        }
        
        UIGraphicsBeginImageContextWithOptions(CGSize(width: 452, height: 540), false, 0)
        GameBadge.drawWhiteBadge()
        
        Cache.imageOfWhiteBadge = UIGraphicsGetImageFromCurrentImageContext()!
        UIGraphicsEndImageContext()
        
        return Cache.imageOfWhiteBadge!
    }
    
    @objc dynamic public class var imageOfBlackBadge: UIImage {
        if Cache.imageOfBlackBadge != nil {
            return Cache.imageOfBlackBadge!
        }
        
        UIGraphicsBeginImageContextWithOptions(CGSize(width: 452, height: 540), false, 0)
        GameBadge.drawBlackBadge()
        
        Cache.imageOfBlackBadge = UIGraphicsGetImageFromCurrentImageContext()!
        UIGraphicsEndImageContext()
        
        return Cache.imageOfBlackBadge!
    }
    
    //// Customization Infrastructure
    
    @objc @IBOutlet dynamic var purpleBadgeTargets: [AnyObject]! {
        get { return Cache.purpleBadgeTargets }
        set {
            Cache.purpleBadgeTargets = newValue
            for target: AnyObject in newValue {
                let _ = target.perform(NSSelectorFromString("setImage:"), with: GameBadge.imageOfPurpleBadge)
            }
        }
    }
    
    @objc @IBOutlet dynamic var greenBadgeTargets: [AnyObject]! {
        get { return Cache.greenBadgeTargets }
        set {
            Cache.greenBadgeTargets = newValue
            for target: AnyObject in newValue {
                let _ = target.perform(NSSelectorFromString("setImage:"), with: GameBadge.imageOfGreenBadge)
            }
        }
    }
    
    @objc @IBOutlet dynamic var blueprintBadgeTargets: [AnyObject]! {
        get { return Cache.blueprintBadgeTargets }
        set {
            Cache.blueprintBadgeTargets = newValue
            for target: AnyObject in newValue {
                let _ = target.perform(NSSelectorFromString("setImage:"), with: GameBadge.imageOfBlueprintBadge)
            }
        }
    }
    
    @objc @IBOutlet dynamic var wetAsphaltBadgeTargets: [AnyObject]! {
        get { return Cache.wetAsphaltBadgeTargets }
        set {
            Cache.wetAsphaltBadgeTargets = newValue
            for target: AnyObject in newValue {
                let _ = target.perform(NSSelectorFromString("setImage:"), with: GameBadge.imageOfWetAsphaltBadge)
            }
        }
    }
    
    @objc @IBOutlet dynamic var goldBadgeTargets: [AnyObject]! {
        get { return Cache.goldBadgeTargets }
        set {
            Cache.goldBadgeTargets = newValue
            for target: AnyObject in newValue {
                let _ = target.perform(NSSelectorFromString("setImage:"), with: GameBadge.imageOfGoldBadge)
            }
        }
    }
    
    @objc @IBOutlet dynamic var asusBlueGreyBadgeTargets: [AnyObject]! {
        get { return Cache.asusBlueGreyBadgeTargets }
        set {
            Cache.asusBlueGreyBadgeTargets = newValue
            for target: AnyObject in newValue {
                let _ = target.perform(NSSelectorFromString("setImage:"), with: GameBadge.imageOfAsusBlueGreyBadge)
            }
        }
    }
    
    @objc @IBOutlet dynamic var redBadgeTargets: [AnyObject]! {
        get { return Cache.redBadgeTargets }
        set {
            Cache.redBadgeTargets = newValue
            for target: AnyObject in newValue {
                let _ = target.perform(NSSelectorFromString("setImage:"), with: GameBadge.imageOfRedBadge)
            }
        }
    }
    
    @objc @IBOutlet dynamic var whiteBadgeTargets: [AnyObject]! {
        get { return Cache.whiteBadgeTargets }
        set {
            Cache.whiteBadgeTargets = newValue
            for target: AnyObject in newValue {
                let _ = target.perform(NSSelectorFromString("setImage:"), with: GameBadge.imageOfWhiteBadge)
            }
        }
    }
    
    @objc @IBOutlet dynamic var blackBadgeTargets: [AnyObject]! {
        get { return Cache.blackBadgeTargets }
        set {
            Cache.blackBadgeTargets = newValue
            for target: AnyObject in newValue {
                let _ = target.perform(NSSelectorFromString("setImage:"), with: GameBadge.imageOfBlackBadge)
            }
        }
    }
    
    
    
    
    @objc(GameBadgeResizingBehavior)
    public enum ResizingBehavior: Int {
        case aspectFit /// The content is proportionally resized to fit into the target rectangle.
        case aspectFill /// The content is proportionally resized to completely fill the target rectangle.
        case stretch /// The content is stretched to match the entire target rectangle.
        case center /// The content is centered in the target rectangle, but it is NOT resized.
        
        public func apply(rect: CGRect, target: CGRect) -> CGRect {
            if rect == target || target == CGRect.zero {
                return rect
            }
            
            var scales = CGSize.zero
            scales.width = abs(target.width / rect.width)
            scales.height = abs(target.height / rect.height)
            
            switch self {
            case .aspectFit:
                scales.width = min(scales.width, scales.height)
                scales.height = scales.width
            case .aspectFill:
                scales.width = max(scales.width, scales.height)
                scales.height = scales.width
            case .stretch:
                break
            case .center:
                scales.width = 1
                scales.height = 1
            }
            
            var result = rect.standardized
            result.size.width *= scales.width
            result.size.height *= scales.height
            result.origin.x = target.minX + (target.width - result.width) / 2
            result.origin.y = target.minY + (target.height - result.height) / 2
            return result
        }
    }
}
